## Retry

- ограничение на кол-во запросов (3 штуки)
- ограничение на таймаут (сколько с можем, но в рамках 200 сек)

### Exponential backoff и Jitter

Exponential backoff и jitter - это стратегии, используемые в сетевых и распределенных системах для управления повторными попытками выполнения операций при возникновении ошибок или задержек. Они помогают уменьшить нагрузку на сеть и улучшить производительность системы в условиях перегрузки или недоступности ресурсов.

Exponential Backoff (Экспоненциальное увеличение интервала между попытками): Это стратегия, при которой интервал времени между каждой последующей попыткой увеличивается в геометрической прогрессии. Например, после первой неудачной попытки может быть задержка в 1 секунду, затем 2 секунды, 4 секунды и так далее. Это позволяет системе избегать бесконечных попыток, которые могут перегрузить сервер или сеть, и дает ресурсам время восстановиться после перегрузки. Экспоненциальное увеличение также помогает снизить конфликты при одновременных повторных попытках.

Jitter (Случайная задержка): Jitter - это случайная задержка, которая добавляется к интервалам времени между попытками. Она используется для снижения сетевой нагрузки и уменьшения вероятности возникновения конфликтов при повторных попытках сразу после истечения задержки. Случайная задержка делает попытки менее синхронными и предотвращает перегрузку серверов при одновременных запросах от множества клиентов.

### Retry After

HTTP заголовок Retry-After используется для информирования клиента о времени, через которое можно будет повторить запрос к серверу, если текущий запрос был отклонен или сервер вернул статус ошибки, указывающий на временную недоступность ресурса или ограничения на запросы.

Этот заголовок имеет несколько важных применений:

Серверная перегрузка: Если сервер перегружен и не способен обработать запрос клиента в данный момент, он может вернуть статус ошибки, такой как 503 Service Unavailable, и включить заголовок Retry-After, чтобы указать, через сколько времени клиенту следует повторить запрос. Это помогает снизить нагрузку на сервер, разрешая клиентам повторять запросы через определенное время вместо бесконечных попыток.

Ограничения на запросы: Некоторые серверы или API могут иметь ограничения на количество запросов, которые клиент может отправить в определенный период времени. Если клиент превышает это ограничение, сервер может вернуть статус ошибки и указать в заголовке Retry-After, когда клиент может снова отправить запрос.

Предупреждение о временной недоступности: Retry-After также может использоваться для предупреждения клиентов о временной недоступности ресурса по плановым причинам, например, для обслуживания или обновления. Это позволяет клиентам заранее знать, когда ресурс снова будет доступен.

Клиенты могут использовать информацию из заголовка Retry-After, чтобы оптимально управлять повторными запросами и избегать избыточных запросов к серверу в случае временной недоступности. Это помогает улучшить эффективность и надежность взаимодействия между клиентами и серверами.

### Ключи идемпотентности

[Ключи идемпотентности (Idempotency Keys)](https://habr.com/ru/companies/yandex/articles/442762/) являются способом обеспечения идемпотентности операций при повторных попытках. Идемпотентность означает, что одна и та же операция, выполненная несколько раз, не приводит к различным результатам, как если бы она была выполнена только один раз.

Когда клиент отправляет запрос на сервер, и этот запрос потенциально может быть повторен из-за сетевых ошибок или других проблем, важно, чтобы сервер мог различать между первоначальным запросом и повторными запросами, чтобы избежать дублирования операций или нежелательных эффектов.

Ключи идемпотентности - это уникальные идентификаторы или значения, включенные в запрос, которые клиент генерирует и отправляет серверу при каждом запросе. Сервер сохраняет ключ идемпотентности для каждого запроса, который он получает, и использует его для определения того, был ли запрос обработан ранее. Если сервер видит ключ идемпотентности, который он уже обработал, то он может проигнорировать повторный запрос и вернуть результат, который был получен при первоначальной обработке.

Примеры ключей идемпотентности включают в себя случайно сгенерированные уникальные идентификаторы, хеши данных запроса или другие механизмы, которые обеспечивают уникальность идентификации запроса. Это позволяет клиентам отправлять повторные запросы без опасности вызвать нежелательные изменения состояния на сервере.

Использование ключей идемпотентности в комбинации с механизмом Retry позволяет обеспечивать безопасность и надежность взаимодействия между клиентом и сервером, даже если запросы повторяются из-за сетевых сбоев или других проблем.

> Важно помнить, что сетевые ошибки могут просиходить при Response, и [сервис может обработать запрос](https://youtu.be/YlXJMCdssAI?si=hL56XhGeawR-XV_D&t=791), хотя клиент получил ошибку.

### Deadlines 

В рамках сетевых запросов могут возникнуть следующие проблемы:

- Сетевые таймауты
- Drop пакетов / обрыв соединения
- Зависание вызываемой зависимости
- Больной / медленный инстанс
-- Проблемы с железом
-- Проблемы с кодом
- Запрашиваемый ресурс недоступен или заблокирован

Решение

- огроничиваем время ожидания на на стороне клиента
- deadline propagation
- время ожидания устанавливается на один ретрай / общее время
- разное время ожидания по разным зависимостям
- лучше устанавливать таймауты по 99-персентилю

#### Deadline propagation

Deadline propagation (пропагация сроков выполнения) - это концепция и практика, используемая в распределенных системах и микросервисной архитектуре для управления сроками выполнения операций и запросов внутри системы. Главная цель deadline propagation - обеспечить предсказуемость и контроль над временными ограничениями при передаче запросов от одной части системы к другой.

Основные аспекты deadline propagation включают в себя:

Установка сроков выполнения: При отправке запроса из одной части системы в другую, исходящий компонент устанавливает срок выполнения (deadline) для этого запроса. Срок выполнения определяет максимально допустимое время, в течение которого запрос должен быть обработан и вернут результат.

Передача сроков выполнения: Срок выполнения передается вместе с запросом при его передаче от компонента к компоненту. Это может осуществляться путем включения срока выполнения в метаданные запроса или через специализированные заголовки.

Контроль и мониторинг: Каждый компонент, который получает запрос, мониторит оставшееся время до срока выполнения и убеждается, что запрос будет обработан и вернет результат до истечения этого срока. Если компонент понимает, что не сможет выполнить запрос вовремя, он может принимать соответствующие решения, например, отклонить запрос или попытаться передать его другому компоненту, который может выполнить его быстрее.

Прозрачность: Важным аспектом deadline propagation является его прозрачность для разработчиков. Это означает, что разработчики не должны активно управлять сроками выполнения на каждом этапе передачи запроса, но система автоматически обрабатывает сроки выполнения и предоставляет механизмы для управления ими.

Deadline propagation помогает предотвратить блокировки и снижает риски, связанные с долгими ожиданиями ответов, в распределенных системах. Это особенно важно в случаях, когда операции зависят друг от друга и должны быть выполнены в согласованных временных рамках.

## Rate Limiting

Проблема:

- Ограниченные ресурсы зависимости
- Спайковый рост трафика
- Незапланированный рост трафика
-- DDOS
-- Естественный рост
- Некоректный / сломанный клиент

Решение:

- Rate Limiting на стороне клиента и сервера
-- Лимитирование по rate'у или кол-ву параллельных запросов
-- Квотирование трафика (X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset)
-- Стандартный HTTP код 429 Too Many Requests / заголовок Retry After
- Burst Limiting 
-- Лимитирование спайковых запросов
-- Лимитирование по rate'у или кол-ву разовых (burst'овых) запросов
-- Лимитирование по кол-ву
- Разные лимиты для разных клиентов

Системы лимитинга: [Token bucket, Leaky bucket, Fixed window, Sliding window](https://cloud.google.com/architecture/rate-limiting-strategies-techniques)

Как его натроить в nginx: [перейти по ссылке](https://docs.nginx.com/nginx/admin-guide/security-controls/controlling-access-proxied-http/).

## [Circuit breaker](https://medium.com/@kirill.sereda/%D1%81%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D0%B8-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-circuit-breaker-pattern-650232944e37)

Проблема:

- Всплеск ошибок
- Повторяющиеся ошибки в зависимости
- Повторяющиеся таймауты и сетевые ошибки
- Повторяющиеся запросы усугубляют состояние системы
- Трата времени, чтобы узнать, что зависимость сломана

Решение:

- Автовыключение зависимостей при всплеске / повторяющихся ошибках
- Проверка восстановления зависимост
-- По истечении таймаута
-- Проба на маленькой части трафика
-- Health checking

Circuit breaker - это популярный паттерн проектирования, применяемый в разработке программного обеспечения и особенно в распределенных системах, для обеспечения более надежной и устойчивой работы приложений. Этот паттерн аналогичен электрическому прерывателю, который может отключить электрическую цепь при перегрузке или сбое, чтобы предотвратить повреждение системы.

Основная идея Circuit breaker заключается в следующем:

Защита от сбоев: Circuit breaker следит за вызовами к какому-то удаленному сервису, функции или ресурсу. Если количество сбоев (например, ошибок или исключений) в этих вызовах превышает определенный порог, Circuit breaker переходит в состояние "отключено" (open).

Предотвращение перегрузки: В состоянии "отключено" Circuit breaker блокирует дополнительные вызовы к удаленному сервису и возвращает ошибку или специальный заглушечный ответ клиенту. Это предотвращает перегрузку удаленного сервиса, что может произойти, если множество запросов продолжают поступать на неисправный или недоступный сервис.

Периодическая проверка на восстановление: Периодически Circuit breaker пытается сделать "пробный" вызов к удаленному сервису, чтобы убедиться, что он снова функционирует корректно. Если пробный вызов успешен, Circuit breaker переходит в состояние "включено" (closed), и запросы снова начинают перенаправляться на удаленный сервис.

Circuit breaker позволяет уменьшить нагрузку на неработающий или перегруженный сервис, улучшить производительность и надежность системы, а также предотвращать ненужные и дорогостоящие попытки обращения к неисправным ресурсам. Этот паттерн широко используется в микросервисных архитектурах, где надежность и устойчивость играют ключевую роль.

Статья от Фаулера: [перейти](https://martinfowler.com/bliki/CircuitBreaker.html)

## Rich Client

Проблема:

- Некотролируемое добавление новых потребителей
- Тяжелая логика в зависимостях
- Повторяющиеся (кэшируемые) результаты вычислений
- Ограниченные ресурсы зависимости
- Ошбики или недоступность зависимости

Решение:

- Перенос части вычислений со стороны сервиса на клиент
-- Равномерное распределение потребления ресурсов
- Вычисления на стороне клиента в случае недоступности сервиса
- Совмещение предыдущих паттернов в одной бибилиотеке

Например: [A/B сервис](https://youtu.be/YlXJMCdssAI?si=bLyzsh-98w5k8ItC&t=2431).

## Dummy

Проблема:

- Масштабный инцидент
- Полная недоступность своего сервиса
-- Сломанный релизи или сломанная миграция БД
-- Недоступность критических зависимостей
- Тяжелая логика в своем сервисе и ограниченные ресурсы

Решение:

- Упрощенная копия функционала своего сервиса
-- Никакой сложной логики
-- Минимум зависимостей
- Не всем сервисам нужна тыква
- Тыква - последний рубеж

В Dummy может записываться лог.

## Прочие паттерны

- Polyglot persistence 
- Event Driven vs Command Driven
- [Event Driven: Event Notification](https://youtu.be/bAhxpqHfP8I?si=5hiCBqjVj-Yz1nyI&t=572)
- Event Carried state transfer
- Event Driven: Event Sourcing
- CQRS - не пиши туда, где читаешь
- [Gracefull degradation](https://youtu.be/5_9x7czHJOM):
  - Null object pattern
  - [Circuit breaker (каскадные timeout)](https://medium.com/@kirill.sereda/%D1%81%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D0%B8-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-circuit-breaker-pattern-650232944e37)
  - Health check + кэши спереди бэка под нагрузкой
    - На стороне клиента
    - На стороне сервиса
- Caching and Failover Caching
- Dynamic Configuration
- Failover
- Blue/Green, Canary deploys
